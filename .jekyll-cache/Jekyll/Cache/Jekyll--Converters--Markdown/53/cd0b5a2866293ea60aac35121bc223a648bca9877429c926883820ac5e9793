I"{æ<h2 id="bioconductor">Bioconductor</h2>

<p>Bioconductor  is an open source, open development software project to provide
tools for the analysis and comprehension of high-throughput genomic data.
Bioconductor is similar to CRAN as an interface to access R packages, but
contains packages that are more biology oriented and
curated by the team of experts.</p>

<p>As bioinformaticians you will most likely operate within Bioconductor
universe. It is designed with interchangeability in mind, many packages work
together and creation of power-full pipelines becomes possible.</p>

<p>To install Bioconductor visit <a href="http://bioconductor.org/install/">this</a> page or do:</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("https://bioconductor.org/biocLite.R")
biocLite()
</code></pre></div></div>

<p>Lets install packages that will be useful in this lesson.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>biocLite(c("IRanges", "GenomicRanges", "ShortRead", "Biostrings", "ggbio"))
</code></pre></div></div>

<p>Take a look how Bioconductor core packages are structured below. We will go through some of these
packages. If you open any of these packages in the Bioconductor website, you can find there
vignettes explaining in detail how to use them.</p>

<pre style="background-color: white; border: none; font-family: monospace, monospace;">
                   VariantAnnotation                Annotate variants, predict coding outcomes.
                           |
                           v
                    GenomicFeatures                 Making and manipulating annotations.
                           |
                           v
                       BSgenome                     Representation of full genomes and their SNPs.
                           |
                           v
                      rtracklayer                   Manipulating annotation tracks eg.BED, GFF, BigWig.
                           |
                           v
                    GenomicAlignments               Manipulation of short genomic alignments.
                      |           |
                      v           v
     SummarizedExperiment   Rsamtools  ShortRead    Load, contain and manipulate different data types.
                  |         |      |      |
                  v         v      v      v
                GenomicRanges     Biostrings        Lower level representations of short sequences.
                        |          |
                        v          v
               GenomeInfoDb   (XVector)             Utilities for genomic coordinates.
                        |     |
                        v     v
                        IRanges                     Representation of ranged data.
                           |
                           v
                      (S4Vectors)                   S4 implementation of vectors and lists.
</pre>

<h2 id="iranges">IRanges</h2>

<p><a href="http://bioconductor.org/packages/release/bioc/html/IRanges.html">IRanges</a> package
 designed to represent sequences, ranges representing indices along those sequences,
and data related to those ranges. IRanges are very fast and provide multiple useful
function to operate on them.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(IRanges)
ir &lt;- IRanges(c(1, 5, 14, 15, 19, 34, 40), width = c(12, 6, 6, 15, 6, 2, 7))
ir
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IRanges object with 7 ranges and 0 metadata columns:
          start       end     width
      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;
  [1]         1        12        12
  [2]         5        10         6
  [3]        14        19         6
  [4]        15        29        15
  [5]        19        24         6
  [6]        34        35         2
  [7]        40        46         7
</code></pre></div></div>

<p>Lets use function below to plot our ranges. Notice widths, are they what you would expect?</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plotRanges &lt;- function(x) {
  height &lt;- 1
  sep &lt;- 0.5
  xlim &lt;- c(min(start(x)), max(end(x)))
  bins &lt;- disjointBins(IRanges(start(x), end(x) + 1))
  plot.new()
  plot.window(xlim, c(0, max(bins)*(height + sep)))
  ybottom &lt;- bins * (sep + height) - height
  rect(start(x) - 0.5, ybottom, end(x) + 0.5, ybottom + height)
  axis(1)
}
plotRanges(ir)
</code></pre></div></div>

<p><img src="../fig/rmd-16-plotRanges-1.png" title="plot of chunk plotRanges" alt="plot of chunk plotRanges" style="display: block; margin: auto;" /></p>

<blockquote class="challenge">
  <h2 id="challenge-1">Challenge 1</h2>

  <p>Create same plot as in plotRanges, but using ggplot2. How similar looking plot you can make?</p>

  <p>Hint: Use <code class="language-plaintext highlighter-rouge">geom_rect</code>.</p>

  <blockquote class="solution">
    <h2 id="solution-to-challenge-1">Solution to challenge 1</h2>

    <div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plotRanges_gg &lt;- function(x) {
  bins &lt;- disjointBins(IRanges(start(ir), end(ir) + 1))
  dat &lt;- cbind(as.data.frame(ir), bin = bins)
  ggplot2::ggplot(dat) +
    ggplot2::geom_rect(ggplot2::aes(xmin = start - 0.5, xmax = end + 0.5,
                       ymin = bin, ymax = bin + 0.9), fill = "#FFFFFF", colour = "black") +
    ggplot2::theme_bw() +
    ggplot2::theme(axis.title.y = ggplot2::element_blank(),
                   axis.text.y = ggplot2::element_blank(),
                   axis.ticks.y = ggplot2::element_blank(),
                   panel.grid.major = ggplot2::element_blank(),
                   panel.grid.minor = ggplot2::element_blank(),
                   panel.border = ggplot2::element_blank(),
                   axis.line.x = ggplot2::element_line(colour = "black"))
}
plotRanges_gg(ir)
</code></pre></div>    </div>

    <p><img src="../fig/rmd-16-plotRanges_gg-1.png" title="plot of chunk plotRanges_gg" alt="plot of chunk plotRanges_gg" style="display: block; margin: auto;" /></p>
  </blockquote>
</blockquote>

<p>You can subset IRanges like any other vector.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ir &lt;- ir[2]
ir
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IRanges object with 1 range and 0 metadata columns:
          start       end     width
      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;
  [1]         5        10         6
</code></pre></div></div>

<p>Here are some operations performed on IRanges. Try them out.</p>

<p><img src="../fig/16-iranges-operations.png" alt="" /></p>

<h2 id="genomicranges">GenomicRanges</h2>

<p>The goal of <a href="http://bioconductor.org/packages/release/bioc/html/GenomicRanges.html">GenomicRanges</a> is to provide general containers for genomic data. The central class, at least from the user
perspective, is GRanges, which formalizes the notion of ranges, while allowing for arbitrary ‚Äúmetadata columns‚Äù to be
attached to it. These columns offer the same flexibility as the venerable data.frame and permit users to adapt GRanges
to a wide variety of adhoc use-cases. To represent genomic location we need to have information about strand and chromosome names,
here called <code class="language-plaintext highlighter-rouge">seqnames</code>.</p>

<p>Lets construct our first <code class="language-plaintext highlighter-rouge">GRanges</code> object containing 10 genomic ranges.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(GenomicRanges)

gr &lt;- GRanges(
  seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)),
  ranges = IRanges(101:110, end = 111:120,
  names = head(letters, 10)),
  strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)),
  score = 1:10,
  GC = seq(1, 0, length=10))
gr
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GRanges object with 10 ranges and 2 metadata columns:
    seqnames    ranges strand |     score        GC
       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;
  a     chr1   101-111      - |         1  1.000000
  b     chr2   102-112      + |         2  0.888889
  c     chr2   103-113      + |         3  0.777778
  d     chr2   104-114      * |         4  0.666667
  e     chr1   105-115      * |         5  0.555556
  f     chr1   106-116      + |         6  0.444444
  g     chr3   107-117      + |         7  0.333333
  h     chr3   108-118      + |         8  0.222222
  i     chr3   109-119      - |         9  0.111111
  j     chr3   110-120      - |        10  0.000000
  -------
  seqinfo: 3 sequences from an unspecified genome; no seqlengths
</code></pre></div></div>

<p>Minimum to construct GRanges object is seqnames, ranges and strand. In your mind you can view GRanges as a data.frame, with special
caveats. You probably noticed that <code class="language-plaintext highlighter-rouge">ranges</code> column contains object of <code class="language-plaintext highlighter-rouge">IRanges</code> that you have already seen in previous chapter. <code class="language-plaintext highlighter-rouge">seqnames</code> and <code class="language-plaintext highlighter-rouge">strand</code> contain <code class="language-plaintext highlighter-rouge">Rle</code> which stands for run-length encoding, a special type of vector that can compress very long repetitive vectors (like in genomes) into short representations. The <code class="language-plaintext highlighter-rouge">score</code> and <code class="language-plaintext highlighter-rouge">GC</code> are metadata columns, added as example. You can add any number of metadata columns holding extra information about your ranges. <code class="language-plaintext highlighter-rouge">names</code> is additional selector for our ranges,
ranges can be subsetted like any other vector with <code class="language-plaintext highlighter-rouge">[1]</code>, now we can also use their names with <code class="language-plaintext highlighter-rouge">[a]</code>. GRanges are vector like objects and they support all vector operations eg. c(), split(), ==, order(), unique().</p>

<p>Each genomic range is described by a chromosome name, a start, an end, and a
strand. <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">end</code> are both 1-based positions relative to the 5‚Äô end of the plus strand
of the chromosome, even when the range is on the minus strand - same as in IRanges.
<code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">end</code> are both considered to be included in the interval (except when the
range is empty). The width of the range is the number of genomic positions included in it. So
width = end - start + 1. <code class="language-plaintext highlighter-rouge">end</code> is always &gt;= <code class="language-plaintext highlighter-rouge">start</code>, except for empty ranges (a.k.a. zero-width ranges) where
end = start - 1. Note that the start is always the leftmost position and the end the rightmost, even
when the range is on the minus strand.
Gotcha: A TSS (Transcription Start Site) is at the end of the range associated with a transcript located on the
minus strand.</p>

<p>Figure out how to access all information in GRanges object.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seqnames(gr)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>factor-Rle of length 10 with 4 runs
  Lengths:    1    3    2    4
  Values : chr1 chr2 chr1 chr3
Levels(3): chr1 chr2 chr3
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>start(gr)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [1] 101 102 103 104 105 106 107 108 109 110
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gr$GC
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [1] 1.0000000 0.8888889 0.7777778 0.6666667 0.5555556 0.4444444 0.3333333
 [8] 0.2222222 0.1111111 0.0000000
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>names(gr)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mcols(gr)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DataFrame with 10 rows and 2 columns
      score        GC
  &lt;integer&gt; &lt;numeric&gt;
a         1  1.000000
b         2  0.888889
c         3  0.777778
d         4  0.666667
e         5  0.555556
f         6  0.444444
g         7  0.333333
h         8  0.222222
i         9  0.111111
j        10  0.000000
</code></pre></div></div>

<p>GRanges also contain some extra accessors and setters. You can use these to get more general, aggregate information about your ranges.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seqinfo(gr)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Seqinfo object with 3 sequences from an unspecified genome; no seqlengths:
  seqnames seqlengths isCircular genome
  chr1             NA         NA   &lt;NA&gt;
  chr2             NA         NA   &lt;NA&gt;
  chr3             NA         NA   &lt;NA&gt;
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seqlevels(gr)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1] "chr1" "chr2" "chr3"
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seqlengths(gr)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chr1 chr2 chr3 
  NA   NA   NA 
</code></pre></div></div>

<p>Real life example can look somewhat like this:</p>

<p><img src="../fig/16-granges-exons-hg19.png" alt="" /></p>

<p>In the example above GRanges contains all exons from from hg19 UCSC database. Now to the point. What makes GRanges wholesome is all ranged-based operations they support and their speed. Practically, all operations supported by <code class="language-plaintext highlighter-rouge">IRanges</code> are also supported by <code class="language-plaintext highlighter-rouge">GRanges</code>, there is many more than mentioned before.</p>

<ul>
  <li>Intra range transformations: <code class="language-plaintext highlighter-rouge">shift()</code>, <code class="language-plaintext highlighter-rouge">narrow()</code>, <code class="language-plaintext highlighter-rouge">resize()</code>, <code class="language-plaintext highlighter-rouge">flank()</code></li>
  <li>Inter range transformations: <code class="language-plaintext highlighter-rouge">range()</code>, <code class="language-plaintext highlighter-rouge">reduce()</code>, <code class="language-plaintext highlighter-rouge">gaps()</code>, <code class="language-plaintext highlighter-rouge">disjoin()</code></li>
  <li>Range-based set operations: <code class="language-plaintext highlighter-rouge">union()</code>, <code class="language-plaintext highlighter-rouge">intersect()</code>, <code class="language-plaintext highlighter-rouge">setdiff()</code>, <code class="language-plaintext highlighter-rouge">punion()</code>, <code class="language-plaintext highlighter-rouge">pintersect()</code></li>
  <li>Coverage and slicing: <code class="language-plaintext highlighter-rouge">coverage()</code>, <code class="language-plaintext highlighter-rouge">slice()</code></li>
  <li>Finding/counting overlapping ranges: <code class="language-plaintext highlighter-rouge">findOverlaps()</code>, <code class="language-plaintext highlighter-rouge">countOverlaps()</code></li>
  <li>Finding the nearest range neighbor: <code class="language-plaintext highlighter-rouge">nearest()</code>, <code class="language-plaintext highlighter-rouge">precede()</code>, <code class="language-plaintext highlighter-rouge">follow()</code></li>
</ul>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plotRanges(ranges(gr))
</code></pre></div></div>

<p><img src="../fig/rmd-16-unnamed-chunk-9-1.png" title="plot of chunk unnamed-chunk-9" alt="plot of chunk unnamed-chunk-9" style="display: block; margin: auto;" /></p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plotRanges(ranges(reduce(gr))) # Why reduce does not work?
</code></pre></div></div>

<p><img src="../fig/rmd-16-unnamed-chunk-9-2.png" title="plot of chunk unnamed-chunk-9" alt="plot of chunk unnamed-chunk-9" style="display: block; margin: auto;" /></p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strand(gr) &lt;- "*"
plotRanges(ranges(reduce(gr)))
</code></pre></div></div>

<p><img src="../fig/rmd-16-unnamed-chunk-9-3.png" title="plot of chunk unnamed-chunk-9" alt="plot of chunk unnamed-chunk-9" style="display: block; margin: auto;" /></p>

<p>Take your time and check out other operations on GRanges.</p>

<blockquote class="challenge">
  <h2 id="challenge-2">Challenge 2</h2>

  <p>Find genomic regions not covered by given set of <code class="language-plaintext highlighter-rouge">exons</code>. Calculate coverage of those regions using ranges defined in <code class="language-plaintext highlighter-rouge">reads</code>.</p>

  <div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set.seed(42) # Why is it used here?
exons &lt;- GRanges(seqnames = 1, ranges = IRanges(seq(1, 100, 10), width = 9), strand = "*")
seqlengths(exons) &lt;- 100 # What does this change?
reads &lt;- GRanges(seqnames = 1, ranges = IRanges(sample.int(100, 1000, replace = TRUE), width = 2), strand = "*")
</code></pre></div>  </div>

  <blockquote class="solution">
    <h2 id="solution-to-challenge-2">Solution to challenge 2</h2>
    <p>Set seed makes sure we all have the same results, as we use sampling to create <code class="language-plaintext highlighter-rouge">reads</code>.
Setting lengths of chromosomes makes <code class="language-plaintext highlighter-rouge">gaps()</code> be aware that there is no exons with <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">-</code> strand.
As all <code class="language-plaintext highlighter-rouge">reads</code> are on <code class="language-plaintext highlighter-rouge">*</code> strand, all will fall into gaps of genomic locations on <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">-</code> strands, hence 1000.</p>

    <div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exons_gaps &lt;- gaps(exons)
countOverlaps(exons_gaps, reads)
</code></pre></div>    </div>

    <div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [1] 1000 1000   26   28   23   19   22   18   17   21   21   21
</code></pre></div>    </div>
  </blockquote>
</blockquote>

<p>Now, if you have played with above operations a bit, you might have noticed that sometimes as result you will get <code class="language-plaintext highlighter-rouge">GRangesList</code>.
There is support in <code class="language-plaintext highlighter-rouge">IRanges</code> and <code class="language-plaintext highlighter-rouge">GenomicRanges</code> packages for Lists. <code class="language-plaintext highlighter-rouge">GRanges</code> inside the list have to be relative to the same genome and they have to have the same metadata columns.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grl &lt;- split(gr, seqnames(gr))
grl
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GRangesList object of length 3:
$chr1
GRanges object with 3 ranges and 2 metadata columns:
    seqnames    ranges strand |     score        GC
       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;
  a     chr1   101-111      * |         1  1.000000
  e     chr1   105-115      * |         5  0.555556
  f     chr1   106-116      * |         6  0.444444
  -------
  seqinfo: 3 sequences from an unspecified genome; no seqlengths

$chr2
GRanges object with 3 ranges and 2 metadata columns:
    seqnames    ranges strand |     score        GC
       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;
  b     chr2   102-112      * |         2  0.888889
  c     chr2   103-113      * |         3  0.777778
  d     chr2   104-114      * |         4  0.666667
  -------
  seqinfo: 3 sequences from an unspecified genome; no seqlengths

$chr3
GRanges object with 4 ranges and 2 metadata columns:
    seqnames    ranges strand |     score        GC
       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;
  g     chr3   107-117      * |         7  0.333333
  h     chr3   108-118      * |         8  0.222222
  i     chr3   109-119      * |         9  0.111111
  j     chr3   110-120      * |        10  0.000000
  -------
  seqinfo: 3 sequences from an unspecified genome; no seqlengths
</code></pre></div></div>

<p>They still have the most important accessors.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>length(grl)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1] 3
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seqnames(grl)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RleList of length 3
$chr1
factor-Rle of length 3 with 1 run
  Lengths:    3
  Values : chr1
Levels(3): chr1 chr2 chr3

$chr2
factor-Rle of length 3 with 1 run
  Lengths:    3
  Values : chr2
Levels(3): chr1 chr2 chr3

$chr3
factor-Rle of length 4 with 1 run
  Lengths:    4
  Values : chr3
Levels(3): chr1 chr2 chr3
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strand(grl)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RleList of length 3
$chr1
factor-Rle of length 3 with 1 run
  Lengths: 3
  Values : *
Levels(3): + - *

$chr2
factor-Rle of length 3 with 1 run
  Lengths: 3
  Values : *
Levels(3): + - *

$chr3
factor-Rle of length 4 with 1 run
  Lengths: 4
  Values : *
Levels(3): + - *
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ranges(grl)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IRangesList object of length 3:
$chr1
IRanges object with 3 ranges and 0 metadata columns:
        start       end     width
    &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;
  a       101       111        11
  e       105       115        11
  f       106       116        11

$chr2
IRanges object with 3 ranges and 0 metadata columns:
        start       end     width
    &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;
  b       102       112        11
  c       103       113        11
  d       104       114        11

$chr3
IRanges object with 4 ranges and 0 metadata columns:
        start       end     width
    &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;
  g       107       117        11
  h       108       118        11
  i       109       119        11
  j       110       120        11
</code></pre></div></div>

<p>Metadata columns are now separated into inner (at the GRanges level) and outer (at the GRangesList level) metadata columns.
<code class="language-plaintext highlighter-rouge">GRangesList</code> supprt only <code class="language-plaintext highlighter-rouge">c()</code>, <code class="language-plaintext highlighter-rouge">length()</code>, <code class="language-plaintext highlighter-rouge">names()</code> and subsetting with <code class="language-plaintext highlighter-rouge">[]</code> from vector operations, but all standard list operations eg. <code class="language-plaintext highlighter-rouge">lapply()</code>, <code class="language-plaintext highlighter-rouge">sapply()</code>, <code class="language-plaintext highlighter-rouge">endoapply()</code>, <code class="language-plaintext highlighter-rouge">elementNROWS()</code>, <code class="language-plaintext highlighter-rouge">unlist()</code> are supported. Standard ranged operations
are also supported.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mcols(grl)$id &lt;- paste0("ID", seq_along(grl))
mcols(grl) # outer metadata
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DataFrame with 3 rows and 1 column
              id
     &lt;character&gt;
chr1         ID1
chr2         ID2
chr3         ID3
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mcols(unlist(grl, use.names = FALSE)) # inner metadata
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DataFrame with 10 rows and 2 columns
      score        GC
  &lt;integer&gt; &lt;numeric&gt;
a         1  1.000000
e         5  0.555556
f         6  0.444444
b         2  0.888889
c         3  0.777778
d         4  0.666667
g         7  0.333333
h         8  0.222222
i         9  0.111111
j        10  0.000000
</code></pre></div></div>

<p>With these above packages you can now manipulate your reads in many ways and calculate meaningful statistics. You know from previous lessons how to load different kinds of data, but genomic data has so many different formats. There is a lot of support from Bioconductor to load up genomic data in an easy way. Lets take a look at <code class="language-plaintext highlighter-rouge">ShortRead</code> package.</p>

<h2 id="shortread">ShortRead</h2>

<p><code class="language-plaintext highlighter-rouge">ShortRead</code> implements sampling, iteration, and input of FASTQ files. The package includes functions for filtering and trimming reads, and for generating a quality assessment report. Data are represented as DNAStringSet-derived objects, and easily manipulated for a diversity of purposes. The package also contains legacy support for early single-end, ungapped alignment formats.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(ShortRead)
fl &lt;- system.file(package = "ShortRead", "extdata", "E-MTAB-1147", "ERR127302_1_subset.fastq.gz")
fq &lt;- readFastq(fl)
fq
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class: ShortReadQ
length: 20000 reads; width: 72 cycles
</code></pre></div></div>

<p>If you will have to parse large fastq files, it‚Äôs better to do this in streams, but it‚Äôs not our goal to create elaborate systems in this lesson. Above is simple, yet effective way of loading up data from fastq file. Notice the sample data is unpacked by the function on the fly. Yet, there is another class representing our data. There is many classes in Bioconductor, each of them has its own purpose. We will take a closer look later. You don‚Äôt need to be very intimate with every class to use it. You can always treat new, unknown classes as containers for data. You know you can always access data using <code class="language-plaintext highlighter-rouge">slot()</code> to force your way. You should avoid this kind of data access, unless you know exactly what are you doing.</p>

<p>Lets try quick exercise in quality filtering our fastq reads. First of all, without loading the file into memory we can create quality report. Run commands below. Report paths in automatically generated in your temporary directory, where you can store all kind of temporary files (function <code class="language-plaintext highlighter-rouge">tempdir()</code> or <code class="language-plaintext highlighter-rouge">tempfile()</code>). Paste path that you see into your browser to check out quality report.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>qa_fq &lt;- qa(fl)
report(qa_fq)
</code></pre></div></div>

<p>Lets filter out all reads with bad nucleotides.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filtered_fq &lt;- fq[nFilter()(fq)]
</code></pre></div></div>

<p>Above <code class="language-plaintext highlighter-rouge">()()</code> is a closure, first bracket is gonna output a function (nFilter is a function that outputs a function!), while second bracer is taking parameters for that output function. Closures are functional construct that are used in more abstract programming to create for example function factory. If you are interested in knowing more <a href="http://adv-r.had.co.nz/Functional-programming.html#closures">here</a> is good resource. You can also achieve the same
goal by doing.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nF &lt;- nFilter()
all(nF(fq) == nFilter()(fq))
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1] TRUE
</code></pre></div></div>

<blockquote class="challenge">
  <h2 id="challenge-3">Challenge 3</h2>

  <p>Lets assume we want to filter out all reads with average base quality below 30. How would you approach this problem?</p>

  <blockquote class="solution">
    <h2 id="solution-to-challenge-3">Solution to challenge 3</h2>

    <div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code># custom filter: mean calibrated base call quality &gt; 30
avgQFilter &lt;- srFilter(function(x) {
    apply(as(quality(x), "matrix"), 1, mean, na.rm = TRUE) &gt; 30
}, name="GoodQualityBases")
fq[avgQFilter(fq)]
</code></pre></div>    </div>

    <div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class: ShortReadQ
length: 16736 reads; width: 72 cycles
</code></pre></div>    </div>
  </blockquote>
</blockquote>

<p>This is an example of loading data into R and manipulating it. Now, after quality filtering lets assume that we want to process our reads a bit more. For that we need to extract sequences and operate on them. <code class="language-plaintext highlighter-rouge">DNAStringSet</code> is one of those classes that can hold string information, usually reads. Let‚Äôs explore them a bit more.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq &lt;- sread(filtered_fq)
seq
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DNAStringSet object of length 19471:
        width seq
    [1]    72 GTCTGCTGTATCTGTGTCGGCTGTCTCGCGGG...CAATGAAGGCCTGGAATGTCACTACCCCCAG
    [2]    72 CTAGGGCAATCTTTGCAGCAATGAATGCCAAT...GTGGCTTTTGAGGCCAGAGCAGACCTTCGGG
    [3]    72 TGGGCTGTTCCTTCTCACTGTGGCCTGACTAA...GCATTAAGAAAGAGTCACGTTTCCCAAGTCT
    [4]    72 CTCATCCACACCTTTGGTCTTGATGGCTGTTT...AAGCATCCCGCTCAGCATCAAAGTTAGTATA
    [5]    72 GTTTGGATATATGGAGGATGGGGATTATTGCT...ATGGATAGTAATAGGGCAAGGACGCCTCCTA
    ...   ... ...
[19467]    72 GCGGGAGCGGCCAAAATGAAGTTTAATCCCTT...CGACCGAAGCAAGAATCGCAAAAGGCATTTC
[19468]    72 TTGTAATCTACTCTTGAACAAAGAATATTTAG...CAGTTTGTTGGGCAGCTAATAGTGTGAACCA
[19469]    72 TGTTGATGGTGCTGGTTACTGGGCCGTGGCTC...GGGTCCCTGCAGTTACACACAGCCCTGCCTC
[19470]    72 CGGAGGTGCAGCCCCCGCCCAAGCGGCGGCAG...ACCACACACAACCTGCCCGAGTTCATTGTGA
[19471]    72 GCAAGGGCGTCATGCTGGCCGTCAGCCAGGGC...ACCAACGGGCTCAACATCCCCAACGAGGACT
</code></pre></div></div>

<h2 id="biostrings">Biostrings</h2>

<p><code class="language-plaintext highlighter-rouge">Biostrings</code> - Memory efficient string containers, string matching algorithms, and other utilities, for fast manipulation of large biological sequences or sets of sequences. You probably noticed that with regular <code class="language-plaintext highlighter-rouge">character</code> you can‚Äôt do many operations that you would like to. The basic subsetting with the use of <code class="language-plaintext highlighter-rouge">[]</code> won‚Äôt do, <code class="language-plaintext highlighter-rouge">Biostrings</code> comes to the rescue. <code class="language-plaintext highlighter-rouge">DNAStringSet</code> contains <code class="language-plaintext highlighter-rouge">DNAString</code> objects and supports many standard character vector operations.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(Biostrings) # Why there was no need to load it here?

length(seq)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1] 19471
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>names(seq)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NULL
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>head(seq, 3)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DNAStringSet object of length 3:
    width seq
[1]    72 GTCTGCTGTATCTGTGTCGGCTGTCTCGCGGGAC...GTCAATGAAGGCCTGGAATGTCACTACCCCCAG
[2]    72 CTAGGGCAATCTTTGCAGCAATGAATGCCAATGG...CAGTGGCTTTTGAGGCCAGAGCAGACCTTCGGG
[3]    72 TGGGCTGTTCCTTCTCACTGTGGCCTGACTAAAA...TGGCATTAAGAAAGAGTCACGTTTCCCAAGTCT
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rev(seq)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DNAStringSet object of length 19471:
        width seq
    [1]    72 GCAAGGGCGTCATGCTGGCCGTCAGCCAGGGC...ACCAACGGGCTCAACATCCCCAACGAGGACT
    [2]    72 CGGAGGTGCAGCCCCCGCCCAAGCGGCGGCAG...ACCACACACAACCTGCCCGAGTTCATTGTGA
    [3]    72 TGTTGATGGTGCTGGTTACTGGGCCGTGGCTC...GGGTCCCTGCAGTTACACACAGCCCTGCCTC
    [4]    72 TTGTAATCTACTCTTGAACAAAGAATATTTAG...CAGTTTGTTGGGCAGCTAATAGTGTGAACCA
    [5]    72 GCGGGAGCGGCCAAAATGAAGTTTAATCCCTT...CGACCGAAGCAAGAATCGCAAAAGGCATTTC
    ...   ... ...
[19467]    72 GTTTGGATATATGGAGGATGGGGATTATTGCT...ATGGATAGTAATAGGGCAAGGACGCCTCCTA
[19468]    72 CTCATCCACACCTTTGGTCTTGATGGCTGTTT...AAGCATCCCGCTCAGCATCAAAGTTAGTATA
[19469]    72 TGGGCTGTTCCTTCTCACTGTGGCCTGACTAA...GCATTAAGAAAGAGTCACGTTTCCCAAGTCT
[19470]    72 CTAGGGCAATCTTTGCAGCAATGAATGCCAAT...GTGGCTTTTGAGGCCAGAGCAGACCTTCGGG
[19471]    72 GTCTGCTGTATCTGTGTCGGCTGTCTCGCGGG...CAATGAAGGCCTGGAATGTCACTACCCCCAG
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c(seq, seq)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DNAStringSet object of length 38942:
        width seq
    [1]    72 GTCTGCTGTATCTGTGTCGGCTGTCTCGCGGG...CAATGAAGGCCTGGAATGTCACTACCCCCAG
    [2]    72 CTAGGGCAATCTTTGCAGCAATGAATGCCAAT...GTGGCTTTTGAGGCCAGAGCAGACCTTCGGG
    [3]    72 TGGGCTGTTCCTTCTCACTGTGGCCTGACTAA...GCATTAAGAAAGAGTCACGTTTCCCAAGTCT
    [4]    72 CTCATCCACACCTTTGGTCTTGATGGCTGTTT...AAGCATCCCGCTCAGCATCAAAGTTAGTATA
    [5]    72 GTTTGGATATATGGAGGATGGGGATTATTGCT...ATGGATAGTAATAGGGCAAGGACGCCTCCTA
    ...   ... ...
[38938]    72 GCGGGAGCGGCCAAAATGAAGTTTAATCCCTT...CGACCGAAGCAAGAATCGCAAAAGGCATTTC
[38939]    72 TTGTAATCTACTCTTGAACAAAGAATATTTAG...CAGTTTGTTGGGCAGCTAATAGTGTGAACCA
[38940]    72 TGTTGATGGTGCTGGTTACTGGGCCGTGGCTC...GGGTCCCTGCAGTTACACACAGCCCTGCCTC
[38941]    72 CGGAGGTGCAGCCCCCGCCCAAGCGGCGGCAG...ACCACACACAACCTGCCCGAGTTCATTGTGA
[38942]    72 GCAAGGGCGTCATGCTGGCCGTCAGCCAGGGC...ACCAACGGGCTCAACATCCCCAACGAGGACT
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nchar(seq)[1:10]
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [1] 72 72 72 72 72 72 72 72 72 72
</code></pre></div></div>

<p>Also multiple summaries are possible through <code class="language-plaintext highlighter-rouge">alphabetFrequency()</code>, <code class="language-plaintext highlighter-rouge">letterFrequency()</code>, <code class="language-plaintext highlighter-rouge">dinucleotideFrequency()</code>. Very important for biologists is to be able to easily convert to the other strand with <code class="language-plaintext highlighter-rouge">reverse()</code>, <code class="language-plaintext highlighter-rouge">complement()</code>, <code class="language-plaintext highlighter-rouge">reverseComplement()</code> and translate to amino acids with <code class="language-plaintext highlighter-rouge">translate()</code>. Matching patterns is supported with <code class="language-plaintext highlighter-rouge">matchPattern()</code>, <code class="language-plaintext highlighter-rouge">vmatchPattern()</code> etc. Look through these possibilities.</p>

<p>Biostrings also has alignment options with <code class="language-plaintext highlighter-rouge">pairwiseAlignment()</code>. Lets align filtered reads to the first read and plot distribution of alignment scores.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aln &lt;- pairwiseAlignment(seq, seq[1])
hist(score(aln)) # Why scores are so low?
</code></pre></div></div>

<p><img src="../fig/rmd-16-unnamed-chunk-22-1.png" title="plot of chunk unnamed-chunk-22" alt="plot of chunk unnamed-chunk-22" style="display: block; margin: auto;" /></p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>writePairwiseAlignments(aln[1]) # Lets see first alignment.
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>########################################
# Program: Biostrings (version 2.58.0), a Bioconductor package
# Rundate: Tue Apr 27 20:13:57 2021
########################################
#=======================================
#
# Aligned_sequences: 2
# 1: P1
# 2: S1
# Matrix: NA
# Gap_penalty: 14.0
# Extend_penalty: 4.0
#
# Length: 72
# Identity:      72/72 (100.0%)
# Similarity:    NA/72 (NA%)
# Gaps:           0/72 (0.0%)
# Score: 142.6864
#
#
#=======================================

P1                 1 GTCTGCTGTATCTGTGTCGGCTGTCTCGCGGGACATGAAGTCAATGAAGG     50
                     ||||||||||||||||||||||||||||||||||||||||||||||||||
S1                 1 GTCTGCTGTATCTGTGTCGGCTGTCTCGCGGGACATGAAGTCAATGAAGG     50

P1                51 CCTGGAATGTCACTACCCCCAG     72
                     ||||||||||||||||||||||
S1                51 CCTGGAATGTCACTACCCCCAG     72


#---------------------------------------
#---------------------------------------
</code></pre></div></div>

<blockquote class="challenge">
  <h2 id="challenge-4">Challenge 4</h2>

  <p>Calculate GC content for our filtered reads. Present GC [%] information on a histogram.</p>

  <blockquote class="solution">
    <h2 id="solution-to-challenge-4">Solution to challenge 4</h2>

    <div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>freqs &lt;- alphabetFrequency(seq)
GC = (freqs[,"G"] + freqs[,"C"])/rowSums(freqs)
hist(GC)
</code></pre></div>    </div>

    <p><img src="../fig/rmd-16-unnamed-chunk-23-1.png" title="plot of chunk unnamed-chunk-23" alt="plot of chunk unnamed-chunk-23" style="display: block; margin: auto;" /></p>
  </blockquote>
</blockquote>

<blockquote class="challenge">
  <h2 id="challenge-5">Challenge 5</h2>

  <p>Detect ‚ÄúACTG‚Äù pattern in your reads and remove it from the reads.</p>

  <blockquote class="solution">
    <h2 id="solution-to-challenge-5">Solution to challenge 5</h2>

    <div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>midx &lt;- vmatchPattern("ACTG", seq, fixed=FALSE)
replaceAt(seq, at = midx, value = "")
</code></pre></div>    </div>

    <div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DNAStringSet object of length 19471:
        width seq
    [1]    72 GTCTGCTGTATCTGTGTCGGCTGTCTCGCGGG...CAATGAAGGCCTGGAATGTCACTACCCCCAG
    [2]    72 CTAGGGCAATCTTTGCAGCAATGAATGCCAAT...GTGGCTTTTGAGGCCAGAGCAGACCTTCGGG
    [3]    68 TGGGCTGTTCCTTCTCTGGCCTGACTAAAACC...GCATTAAGAAAGAGTCACGTTTCCCAAGTCT
    [4]    72 CTCATCCACACCTTTGGTCTTGATGGCTGTTT...AAGCATCCCGCTCAGCATCAAAGTTAGTATA
    [5]    72 GTTTGGATATATGGAGGATGGGGATTATTGCT...ATGGATAGTAATAGGGCAAGGACGCCTCCTA
    ...   ... ...
[19467]    72 GCGGGAGCGGCCAAAATGAAGTTTAATCCCTT...CGACCGAAGCAAGAATCGCAAAAGGCATTTC
[19468]    72 TTGTAATCTACTCTTGAACAAAGAATATTTAG...CAGTTTGTTGGGCAGCTAATAGTGTGAACCA
[19469]    68 TGTTGATGGTGCTGGTTGGCCGTGGCTCCAGG...GGGTCCCTGCAGTTACACACAGCCCTGCCTC
[19470]    72 CGGAGGTGCAGCCCCCGCCCAAGCGGCGGCAG...ACCACACACAACCTGCCCGAGTTCATTGTGA
[19471]    72 GCAAGGGCGTCATGCTGGCCGTCAGCCAGGGC...ACCAACGGGCTCAACATCCCCAACGAGGACT
</code></pre></div>    </div>
  </blockquote>
</blockquote>

<p>Finally, lets save our transformed reads as ‚Äú.fasta‚Äù file.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>temp_file &lt;- tempfile()
writeXStringSet(seq, temp_file)
</code></pre></div></div>

<h2 id="ggbio">ggbio</h2>

<p><code class="language-plaintext highlighter-rouge">ggbio</code> - package extends and specializes the grammar of graphics for biological data. The graphics are designed to answer common scientific questions, in particular those often asked of high throughput genomic data. All core Bioconductor data structures are supported, where appropriate. The package supports detailed views of particular genomic regions, as well as genome-wide overviews. Supported overviews include ideograms and grand linear views. High-level plots include sequence fragment length, edge-linked interval to data view, mismatch pileup, and several splicing summaries.</p>

<p>In short <code class="language-plaintext highlighter-rouge">ggbio</code> makes it easy to plot <code class="language-plaintext highlighter-rouge">GRanges</code> data, circular data, emulate genomic browser and plot ideograms! It uses the same syntax as <code class="language-plaintext highlighter-rouge">ggplot2</code>, it build on top of it, and figures out how to align your data for display. lets plot our ranges.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library("ggbio")
autoplot(gr)
</code></pre></div></div>

<p><img src="../fig/rmd-16-unnamed-chunk-26-1.png" title="plot of chunk unnamed-chunk-26" alt="plot of chunk unnamed-chunk-26" style="display: block; margin: auto;" /></p>

<p>How about some ideogram?</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library("biovizBase")
hg19IdeogramCyto &lt;- getIdeogram("hg19", cytoband = TRUE)
</code></pre></div></div>

<div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1] "hg19"
</code></pre></div></div>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plotIdeogram(hg19IdeogramCyto, "chr1")
</code></pre></div></div>

<p><img src="../fig/rmd-16-unnamed-chunk-27-1.png" title="plot of chunk unnamed-chunk-27" alt="plot of chunk unnamed-chunk-27" style="display: block; margin: auto;" /></p>

<p>Plot karyogram depicting information about chromosome sizes.</p>

<div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>autoplot(hg19IdeogramCyto, layout = "karyogram", cytoband = TRUE)
</code></pre></div></div>

<p><img src="../fig/rmd-16-unnamed-chunk-28-1.png" title="plot of chunk unnamed-chunk-28" alt="plot of chunk unnamed-chunk-28" style="display: block; margin: auto;" /></p>

<blockquote class="challenge">
  <h2 id="challenge-6">Challenge 6</h2>
  <p>Plot ranges defined in <code class="language-plaintext highlighter-rouge">gr</code> in karyogram, but make sure to colour them by group.</p>

  <div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data(hg19Ideogram, package= "biovizBase")
set.seed(42)
gr &lt;- GRanges(sample(paste0("chr", 1:13), 50, TRUE), ranges = IRanges(round(runif(50, 1, 1e8)), width = 1000))
seqlengths(gr) &lt;- seqlengths(hg19Ideogram)[names(seqlengths(gr))]
gr$group &lt;- factor(sample(letters[1:4], 50, TRUE))
</code></pre></div>  </div>
  <blockquote class="solution">
    <h2 id="solution-to-challenge-6">Solution to challenge 6</h2>

    <div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>autoplot(seqinfo(gr)) + layout_karyogram(gr, aes(fill=group, color=group))
</code></pre></div>    </div>

    <p><img src="../fig/rmd-16-ranges-1.png" title="plot of chunk ranges" alt="plot of chunk ranges" style="display: block; margin: auto;" /></p>
  </blockquote>
</blockquote>

<blockquote class="challenge">
  <h2 id="challenge-7">Challenge 7</h2>

  <p>Plot the different transcripts for our genes of interest BRCA1 and NBR1.</p>

  <div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data(genesymbol, package = "biovizBase")
library(Homo.sapiens)
</code></pre></div>  </div>
  <blockquote class="solution">
    <h2 id="solution-to-challenge-7">Solution to challenge 7</h2>

    <div class="language-plaintext r highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wh &lt;- genesymbol[c("BRCA1", "NBR1")]
wh &lt;- range(wh, ignore.strand = TRUE)
autoplot(Homo.sapiens, which = wh)
</code></pre></div>    </div>

    <p><img src="../fig/rmd-16-transcripts-1.png" title="plot of chunk transcripts" alt="plot of chunk transcripts" style="display: block; margin: auto;" /></p>
  </blockquote>
</blockquote>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="http://bioconductor.org/packages/release/bioc/vignettes/GenomicRanges/inst/doc/GenomicRangesHOWTOs.pdf">GenomicRanges tutorial</a></li>
  <li>browseVignettes(‚ÄúGenomicRanges‚Äù)</li>
  <li><a href="http://adv-r.had.co.nz/Functional-programming.html#closures">Closures</a></li>
</ul>
:ET